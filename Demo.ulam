local typedef BondStatus BS;
local typedef EventWindow.SiteNum SiteNum;
local typedef EvalSearch ES;
local typedef PackageData PD;
local typedef STypeUtils STU;

/**
   \symbol DP
 */
element DemoParameters {
  /**
     Bootstrap automatically

     Attach TreeBuilder atom to the first item in input sequence.
   */
  parameter Bool pBOOTSTRAP = true;
}


/**
   \symbol De
 */
element Demo : QStateT(3) + QBondableT(2) + QMortal {
  constant State cSTATE_PLACE_MEMBRANE_BUILDER = 0;
  constant State cSTATE_BUILD_SEQUENCE         = 1;
  constant State cSTATE_ATTACH_FIRST           = 2;
  constant State cSTATE_COMPLETE               = 3;
  constant State cSTATE_ATTACH_TREE_BUILDER    = 4;

  Unsigned mCount = 0;

  @Override Void behave() {
    if (isState(cSTATE_PLACE_MEMBRANE_BUILDER)) {
      placeMembraneBuilder();
    } else if (isState(cSTATE_BUILD_SEQUENCE)) {
      buildSequence();
    } else if (isState(cSTATE_ATTACH_FIRST)) {
      attachFirst();
    } else if (isState(cSTATE_COMPLETE)) {
      complete();
    } else if (isState(cSTATE_ATTACH_TREE_BUILDER)) {
      attachTreeBuilder();
    } else if (isState(cSTATE_DONE)) {
      die();
    }
  }

  Void placeMembraneBuilder() {
    EventWindow ew;

    Demo_MembraneBuilder builder;
    ew[1] = builder;

    setState(cSTATE_BUILD_SEQUENCE);
  }

  Void buildSequence() {
    Demo_SequenceData data;

    SequenceBuilder builder;
    if (builder.buildNext(self, 0, data.getData(mCount), data.getAux(mCount)))
      mCount++;

    if (mCount == 2u && !getBond(1).isAttached()) {
      // Attach to first item, so we can close the ring later
      setState(cSTATE_ATTACH_FIRST);

    } else if (mCount >= data.cSIZE) {
      setState(cSTATE_COMPLETE);
    }
  }

  Void attachFirst() {
    BondStatus bs;
    BondUtils bu;
    EventWindow ew;

    QBond& bond = getBond(0);
    SiteNum secondSite = bond.getSiteNumber();
    Package& second = (Package&) ew[secondSite];

    QBond& prevBond = second.getBond(Package.cPREV);
    SiteNum firstSite = prevBond.getSiteNumber(secondSite);

    // Attach to bond 1
    if (bs.isOk(bu.attach(0, 1, firstSite, Package.cCOMMON)))
      setState(cSTATE_BUILD_SEQUENCE); // continue building sequence
  }

  Void complete() {
    BondStatus bs;
    BondUtils bu;

    SiteNum siteFirst = getBond(1).getSiteNumber();
    SiteNum siteLast = getBond(0).getSiteNumber();

    if (bs.isOk(bu.attach(siteFirst, Package.cPREV, siteLast, Package.cNEXT)))
      setState(cSTATE_ATTACH_TREE_BUILDER);
  }

  Void attachTreeBuilder() {
    DemoParameters params;
    if (!params.pBOOTSTRAP) {
      setState(cSTATE_DONE);
      return;
    }

    BondStatus bs;
    BondUtils bu;
    EventWindow ew;
    EventWindowMisc ewm;

    // Get first package
    QBond& firstBond = getBond(1);
    SiteNum firstSite = firstBond.getSiteNumber();
    Package& first = (Package&) ew[firstSite];

    // Place builder
    TreeBuilder builder;
    SiteNum site = ewm.findEmptySiteAround(first, 1u, bu.maxDist(builder, first));
    if (site == SiteNum.maxof)
      return;
    ew[site] = builder;

    // Attach to first package (replace ourselves)
    BS.Status status = bu.replace(firstSite, Package.cCOMMON, site, TreeBuilder.cSEQUENCE);
    if (!bs.isOk(status)) {
      Empty empty;
      ew[site] = empty;
      return;
    }
    setState(cSTATE_DONE);
  }
}

local typedef QBondableT(1) QBondable1;

/**
   \symbol DM
 */
element Demo_MembraneBuilder : QStateT(3) + QBondableT(1) + QDiffusableT(100) + QMortal {
  typedef C2D.Dir Dir;

  constant Unsigned(5) cSIDE_LENGTH = 20;
  constant Unsigned(2) cSTEP_LENGTH = 2;

  constant State cSTATE_MOVE_OUT       = 0;
  constant State cSTATE_BUILD          = 1;
  constant State cSTATE_ANCHOR         = 2;
  constant State cSTATE_TRAVERSE       = 3;
  constant State cSTATE_FORWARD        = 4;
  constant State cSTATE_CLOSE          = 5;
  constant State cSTATE_REMOVE_ANCHORS = 6;

  Dir mDir = 0; // South
  Unsigned(5) mCount = 0;
  Unsigned(2) mMoveCount = 0;

  @Override Void behave() {
    if (isState(cSTATE_MOVE_OUT)) {
      moveOut();
    } else if (isState(cSTATE_BUILD)) {
      build();
    } else if (isState(cSTATE_ANCHOR)) {
      anchor();
    } else if (isState(cSTATE_TRAVERSE)) {
      traverse();
    } else if (isState(cSTATE_FORWARD)) {
      forward();
    } else if (isState(cSTATE_CLOSE)) {
      close();
    } else if (isState(cSTATE_REMOVE_ANCHORS)) {
      removeAnchors();
      diffuse();
    } else if (isState(cSTATE_DONE)) {
      die();
    }
  }

  Void moveOut() {
    // NOTE: cannot do checks after swapping
    if (mCount >= cSIDE_LENGTH * cSTEP_LENGTH / 2) {
      mCount = 0;
      setState(cSTATE_BUILD);
      return;
    }

    EventWindow ew;
    SwapHelper sh;
    C2D origin;
    C2D coord = origin.neighbor(5); // North-West
    if (ew.isEmpty(coord)) {
      mCount++; // increment _before_ swapping
      if (!sh.swap(origin, coord))
        mCount--;
    }
  }

  Void build() {
    BondStatus bs;
    BondUtils bu;
    EventWindow ew;
    EventWindowMisc ewm;

    // Build
    SiteNum site = ewm.findEmptySite(1, 2);
    if (site == SiteNum.maxof)
      return;
    Membrane membrane;
    ew[site] = membrane;

    BS.Status status = BS.cOK;
    QBond& bond = getBond(0);
    if (!bond.isAttached()) {
      // First membrane atom, attach to self
      status = bu.attach(0, 0, site, Membrane.cCOMMON);
    } else {
      // Attach to previous membrane atom
      status = bu.attach(bond.getSiteNumber(), Membrane.cNEXT, site, Membrane.cPREV);
    }

    if (bs.isOk(status)) {
      setState(cSTATE_ANCHOR);

    } else {
      Empty empty;
      ew[site] = empty;
      return;
    }
  }

  Void anchor() {
    BondStatus bs;
    BondUtils bu;
    CoordUtils cu;
    EventWindow ew;
    EventWindowMisc ewm;

    QBond& bond = getBond(0);
    SiteNum membraneSite = bond.getSiteNumber();
    Membrane& membrane = (Membrane&) ew[membraneSite];
    QBond& otherBond = membrane.getBond(Membrane.cOTHER);

    if (mCount > 0 || otherBond.isAttached()) {
      setState(cSTATE_TRAVERSE);
      return;
    }

    // Build anchor
    C2D coord = ew.getCoordRaw(getForwardSite());
    coord = cu.rotateLeft(coord);
    SiteNum site = ew.getSiteNumberRaw(-coord);
    if (!ew.isEmpty(site))
      return;
    Anchor anchor;
    ew[site] = anchor;

    // Attach to membrane
    BS.Status status = bu.attach(site, 0, membraneSite, Membrane.cOTHER);
    if (!bs.isOk(status)) {
      Empty empty;
      ew[site] = empty;
      return;
    }
  }

  Void traverse() {
    BondStatus bs;
    BondUtils bu;
    EventWindow ew;

    BS.Status status = bu.traverse(0, 0, Membrane.cNEXT);
    if (bs.isOk(status) || status == BS.cNO_NEXT)
      setState(cSTATE_FORWARD);
  }

  Void forward() {
    // NOTE: cannot do checks after swapping
    if (mMoveCount >= cSTEP_LENGTH) {
      mMoveCount = 0;
      mCount++;
      if (mCount >= cSIDE_LENGTH) {
        // Side finished, move to next side
        mCount = 0;
        mDir = getNextDir();
        if (mDir == 0) {
          // Last side finished, close the membrane
          setState(cSTATE_CLOSE);
          return;
        }
      }
      setState(cSTATE_BUILD);
      return;
    }

    EventWindow ew;
    SwapHelper sh;

    SiteNum forwardSite = getForwardSite();
    if (ew.isEmpty(forwardSite)) {
      mMoveCount++; // increment _before_ swapping
      if (!sh.swap(0, forwardSite))
        mMoveCount--;
    }
  }

  Void close() {
    BondStatus bs;
    BondUtils bu;
    EventWindow ew;

    QBond& bond = getBond(0);
    SiteNum prevSite = bond.getSiteNumber();
    SiteNum nextSite = getFirstSite();
    if (nextSite == SiteNum.maxof)
      return;

    BS.Status status = bu.attach(prevSite, Membrane.cNEXT, nextSite, Membrane.cPREV);
    if (bs.isOk(status)) {
      mCount = 0;
      setState(cSTATE_REMOVE_ANCHORS);
    }
  }

  Void removeAnchors() {
    BondUtils bu;
    EventWindow ew;

    // Get membrane
    QBond& bond = getBond(0);
    SiteNum membraneSite = bond.getSiteNumber();
    Membrane& membrane = (Membrane&) ew[membraneSite];

    // Get anchor
    QBond& anchorBond = membrane.getBond(Membrane.cOTHER);
    Bool isAttached = anchorBond.isAttached();
    SiteNum anchorSite = isAttached
      ? anchorBond.getSiteNumber(membraneSite)
      : SiteNum.maxof;

    if (isAttached && !ew.isAccessible(anchorSite))
      return;

    if (!isAttached || !(ew[anchorSite] is Anchor)) {
      // no anchor, move to next membrane atom
      bu.traverse(0, 0, Membrane.cNEXT);
      return;
    }

    // Detach and destroy anchor
    anchorBond.detach(membraneSite);
    Empty empty;
    ew[anchorSite] = empty;
    mCount++;

    // Are all anchors removed?
    if (mCount == 4)
      setState(cSTATE_DONE);
  }

  SiteNum getFirstSite() {
    EventWindow ew;
    MDist mdist;

    for (Int s = 1; s <= mdist.getLastIndex(4); s++) {
      SiteNum site = (SiteNum) s;
      Atom& atom = ew[site];
      if (atom as Membrane)
        if (!atom.getBond(Membrane.cPREV).isAttached())
          return site;
    }
    return SiteNum.maxof;
  }

  Dir getNextDir() {
    return (Dir) (((Int) mDir + 2) % 8);
  }

  SiteNum getForwardSite() {
    EventWindow ew;
    C2D origin;
    return ew.getSiteNumber(origin.neighbor(mDir));
  }

  @Override Void renderGraphics() {
    self.QBondable1.renderGraphics();

    Drawable drawable;
    if (!drawable.canDraw())
      return;

    ColorUtils cu;
    C2D start;
    C2D end = start.neighbor(mDir) * (Drawable.cUNITS_PER_SITE * 3 / 4);
    ARGB oncol = cu.color(0x00ffffff);
    ARGB offcol = oncol;
    drawable.drawMaskedLine(start, end, oncol, offcol, 0xffffffff);
  }
}


/**
   Basic crawler example:
   (with-input
     (if-attached
     +-(widh-dst           ;; Move to "next" if possible, otherwise try "other"
     |   Membrane.cNEXT,   ; TODO: shorten to (if-not (traverse-3) (traverse-2))
     |   (if-attached-next
     |     (traverse-3)
     |     (traverse-2)))
     +-(attach-to          ;; Find a membrane to attach to
         STU.cMEMBRANE)))

    1 (with-input
    2   (if-attached
    3   +-(with-reg1
    4   |   ES.cTAGGED | ES.cACTIVE
    5   |   (if-matches-flags
    6   |   +-(prog2
    7   |   |   (prog2
    8   |   |     (deactivate)
    9   |   |     (traverse-2))
   10   |   |   (with-output
   11   |   |     (if
   12   |   |       (with-reg1
   13   |   |         STU.cTREE_BUILDER
   14   |   |         (with-dst
   15   |   |           TreeBuilder.cSEQUENCE
   16   |   |           (build)))
   17   |   |       (with-dst-1
   18   |   |         (with-reg1
   19   |   |           Package.cCOMMON
   20   |   |           (move-to-other-next)))))
   21   |   +-(traverse-2)))
   22   +-(attach-to-flags
   23       STU.cPACKAGE
   24       ES.cNO_EXEC)))

   # Build second membrane layer atoms:
    1 (with-input
    2  (if-attached
    3  +-(with-dst-2                    ; "other" membrane bond
    4  |   (if-attached-next
    5  |   +-(with-dst-3                ;; Move to "next" if attached, otherwise try "other"
    6  |   |   (if-attached-next
    7  |   |     (traverse-3)           ; move to "next" membrane atom
    8  |   |     (traverse-2)))         ; move to "other" membrane atom
    9  |   +-(with-output               ;; Attach new membrane atom to "other" bond
   10  |       (with-dst-2              ; Membrane.cOTHER = 2
   11  |         (if
   12  |           (with-reg1
   13  |             STU.cMEMBRANE      ; membrane stype
   14  |             (build))           ; build attached to Exec by "other" bond
   15  |           (move-to-other))))   ; attach to input membrane's "other" bond
   16  +-(attach-to                     ;; Find a membrane to attach to
   17      STU.cMEMBRANE)))

   # Repair the membrane:
   1. Next layer atoms are there,        2. Atoms of both layers are attached,
      but not attached to each other:       but one layer has extra atoms in between
                                            because of growth:
   "other" layer:   o   o                    -o-------o-
                    |   |                     |       |
   current layer:  -o---o-                   -o---o---o-
                    |                         |
                    @                         @
    1 (with-input
    2   (if-attached
    3   +-(prog2
    4   |   (with-dst-2
    5   |     (if-attached-next                            ; Does current membrane atom have "other"?
    6   |     +-(if
    7   |     | +-(attach-other-to-next)                   ; * attach output bond to "other" membrane
    8   |     | +-(with-dst-3
    9   |     |     (if-attached-next                      ;   Is there next membrane atom?
   10   |     |     +-(prog2
   11   |     |     |   (traverse)                         ;   - move to next
   12   |     |     |   (with-dst-2
   13   |     |     |     (if-attached-next                ;     does next atom have "other" attached?
   14   |     |     |     +-(prog2
   15   |     |     |     |   (traverse)                   ;     1. move to it
   16   |     |     |     |   (with-dst-1
   17   |     |     |     |     (if-other-matches-next     ;     2. is it "next" for output?
   18   |     |     |     |       (noop)                   ;        nothing to do then
   19   |     |     |     |       (with-reg1               ;     3. connect membrane prev/next atoms
   20   |     |     |     |         Membrane.cNEXT         ;        (break bonds if already bonded)
   21   |     |     |     |         (connect-other-force)))))
   22   |     |     |     +-(noop))))
   23   |     |     +-(swap-input-output))))               ;   - no next atom, move to "other"
   24   |     +-(traverse-3))                              ; * move to next
   25   |   (detach-other))                                ; detach output bond
   26   +-(attach-to                                       ;; Find a membrane to attach to
   27       STU.cMEMBRANE)))

 */
transient Demo_SequenceData {
  typedef DataUtils.Datum Datum;
  typedef DataUtils.Byte Byte;
  typedef ITaggable.Tag Tag;
  typedef PackageData.Arity Arity;
  typedef PackageData.Type Type;
  typedef PackageData.Symbol Symbol;

  typedef EvalBlock EB;
  typedef EvalConditional EC;
  typedef EvalFunction EF;

  typedef Bits(Type.sizeof + Byte.sizeof) Item ;

  constant Item cBLCK = (Item) PD.cTYPE_BLOCK << Byte.sizeof;
  constant Item cFUNC = (Item) PD.cTYPE_FUNCTION << Byte.sizeof;
  constant Item cCOND = (Item) PD.cTYPE_CONDITIONAL << Byte.sizeof;
  constant Item cCNST = (Item) PD.cTYPE_CONSTANT << Byte.sizeof;

  constant Item cACTIVE = (Item) 1 << Byte.sizeof;

  constant Unsigned cSIZE = 68;

  PackageData pd;

  EvalBlock eb;
  EvalConditional ec;
  EvalFunction ef;

  Item items[cSIZE * 2] = {
    /* # Bootstrap */
    /*  1 */ cBLCK | EB.cWITH_INPUT, (Tag) 0x1,
    /*  2   */ cCOND | EC.cIF_ATTACHED, 0,
    /*  3     */ cBLCK | EB.cWITH_REG1, 0,
    /*  4       */ cCNST | (Byte) (ES.cTAGGED | ES.cACTIVE), 0,
    /*  5       */ cCOND | EC.cIF_MATCHES_FLAGS, 0,
    /*  6         */ cFUNC | EF.cPROG2, 0,
    /*  7           */ cFUNC | EF.cPROG2, 0,
    /*  8             */ cFUNC | EF.cDEACTIVATE, 0,
    /*  9             */ cFUNC | EF.cTRAVERSE_2, 0,
    /* 10           */ cBLCK | EB.cWITH_OUTPUT, 0,
    /* 11             */ cCOND | EC.cIF, 0,
    /* 12               */ cBLCK | EB.cWITH_REG1, 0,
    /* 13                 */ cCNST | (Byte) STU.cTREE_BUILDER, 0,
    /* 14                 */ cBLCK | EB.cWITH_DST, 0,
    /* 15                   */ cCNST | (Byte) TreeBuilder.cSEQUENCE, 0,
    /* 16                   */ cFUNC | EF.cBUILD, 0,
    /* 17               */ cBLCK | EB.cWITH_DST_1, 0,
    /* 18                 */ cBLCK | EB.cWITH_REG1, 0,
    /* 19                   */ cCNST | (Byte) Package.cCOMMON, 0,
    /* 20                   */ cFUNC | EF.cMOVE_TO_OTHER_NEXT, 0,
    /* 21         */ cFUNC | EF.cTRAVERSE_2, 0,
    /* 22     */ cFUNC | EF.cATTACH_TO_FLAGS, 0,
    /* 23       */ cCNST | (Byte) STU.cPACKAGE, 0,
    /* 24       */ cCNST | (Byte) ES.cNO_EXEC, 0,

    /* # Build second membrane layer atoms */
    /*  1 */ cBLCK | EB.cWITH_INPUT, cACTIVE | (Tag) 0x2,
    /*  2   */ cCOND | EC.cIF_ATTACHED, 0,
    /*  3     */ cBLCK | EB.cWITH_DST_2, 0,
    /*  4       */ cCOND | EC.cIF_ATTACHED_NEXT, 0,
    /*  5         */ cBLCK | EB.cWITH_DST_3, 0,
    /*  6           */ cCOND | EC.cIF_ATTACHED_NEXT, 0,
    /*  7             */ cFUNC | EF.cTRAVERSE_3, 0,
    /*  8             */ cFUNC | EF.cTRAVERSE_2, 0,
    /*  9         */ cBLCK | EB.cWITH_OUTPUT, 0,
    /* 10           */ cBLCK | EB.cWITH_DST_2, 0,
    /* 11             */ cCOND | EC.cIF, 0,
    /* 12               */ cBLCK | EB.cWITH_REG1, 0,
    /* 13                   */ cCNST | (Byte) STU.cMEMBRANE, 0,
    /* 14                   */ cFUNC | EF.cBUILD, 0,
    /* 15                 */ cFUNC | EF.cMOVE_TO_OTHER, 0,
    /* 16     */ cFUNC | EF.cATTACH_TO, 0,
    /* 17       */ cCNST | STU.cMEMBRANE, 0,

    /* # Repair the membrane */
    /*  1 */ cBLCK | EB.cWITH_INPUT, cACTIVE | (Tag) 0x2,
    /*  2   */ cCOND | EC.cIF_ATTACHED, 0,
    /*  3     */ cFUNC | EF.cPROG2, 0,
    /*  4       */ cBLCK | EB.cWITH_DST_2, 0,
    /*  5         */ cCOND | EC.cIF_ATTACHED_NEXT, 0,
    /*  6           */ cCOND | EC.cIF, 0,
    /*  7             */ cFUNC | EF.cATTACH_OTHER_TO_NEXT, 0,
    /*  8             */ cBLCK | EB.cWITH_DST_3, 0,
    /*  9               */ cCOND | EC.cIF_ATTACHED_NEXT, 0,
    /* 10                 */ cFUNC | EF.cPROG2, 0,
    /* 11                   */ cFUNC | EF.cTRAVERSE, 0,
    /* 12                   */ cBLCK | EB.cWITH_DST_2, 0,
    /* 13                     */ cCOND | EC.cIF_ATTACHED_NEXT, 0,
    /* 14                       */ cFUNC | EF.cPROG2, 0,
    /* 15                         */ cFUNC | EF.cTRAVERSE, 0,
    /* 16                         */ cBLCK | EB.cWITH_DST_1, 0,
    /* 17                           */ cCOND | EC.cIF_OTHER_MATCHES_NEXT, 0,
    /* 18                             */ cFUNC | EF.cNOOP, 0,
    /* 19                             */ cBLCK | EB.cWITH_REG1, 0,
    /* 20                               */ cCNST | (Byte) Membrane.cNEXT, 0,
    /* 21                               */ cFUNC | EF.cCONNECT_OTHER_FORCE, 0,
    /* 22                       */ cFUNC | EF.cNOOP, 0,
    /* 23                 */ cFUNC | EF.cSWAP_INPUT_OUTPUT, 0,
    /* 24           */ cFUNC | EF.cTRAVERSE_3, 0,
    /* 25       */ cFUNC | EF.cDETACH_OTHER, 0,
    /* 26   */ cFUNC | EF.cATTACH_TO, 0,
    /* 27     */ cCNST | (Byte) STU.cMEMBRANE, 0
  };

  Datum getData(Unsigned i) {
    Item item = items[i * 2u];

    Type type = (Type) (item >> Byte.sizeof);
    Byte value = (Byte) item;
    Arity arity = getArity(type, (Symbol) value);

    // DebugUtils dbg;
    // dbg.print("sequence item (num/arity):");
    // dbg.print(i + 1u);
    // dbg.print(arity);

    Datum data = PD.cNO_DATA;
    data = pd.setArity(data, arity);
    data = pd.setType(data, type);
    data = pd.setValue(data, value);
    return data;
  }

  Datum getAux(Unsigned i) {
    Item item = items[i * 2u + 1u];

    Tag tag = (Tag) item;
    Bool isActive = (item & cACTIVE) != 0x0;

    Datum data = PD.cNO_DATA;
    if (tag != 0x0) {
      data = pd.setTag(data, tag);
      data = pd.setIsActive(data, isActive);
    }
    return data;
  }

  Arity getArity(Type type, Symbol symbol) {
    Arity arity = 0;
    if (type == PD.cTYPE_BLOCK) {
      arity = eb.getArity(symbol);
    } else if (type == PD.cTYPE_CONDITIONAL) {
      arity = ec.getArity(symbol);
    } else if (type == PD.cTYPE_FUNCTION) {
      arity = ef.getArity(symbol);
    }
    return arity;
  }
}


/**
   Build second membrane layer, hardcoded for testing

   \symbol DL
 */
element Demo_MembraneLayerBuilder : Demo_MembraneCrawler {
  @Override Void behave() {
    step();
    diffuse();
  }

  @Override Bool doWork() {
    BondStatus bs;
    BondUtils bu;
    EventWindow ew;
    EventWindowMisc ewm;

    QBond& bond = getBond(0);
    SiteNum site = bond.getSiteNumber();

    // Get current membrane atom
    IBondable& bondable = (IBondable&) ew[site];
    QBond& otherBond = bondable.getBond(Membrane.cOTHER);
    if (otherBond.isAttached())
      return true; // already has "other" atom attached

    // Place new membrane atom
    Membrane membrane;
    SiteNum otherSite = ewm.findEmptySiteAround(site, 1, bu.maxDist(membrane, bondable));
    if (otherSite == SiteNum.maxof)
      return false;
    ew[otherSite] = membrane;

    // Attach
    if (!bs.isOk(bu.attach(site, Membrane.cOTHER, otherSite, Membrane.cOTHER))) {
      Empty empty;
      ew[otherSite] = empty;
      return false;
    }
    return true;
  }
}


/**
   \symbol DR
 */
element Demo_MembraneRepair : Demo_MembraneCrawler {
  @Override Void behave() {
    step();
    diffuse();
  }

  @Override Bool doWork() {
    BondStatus bs;
    BondUtils bu;
    EventWindow ew;

    /*
           other  otherNext/nextOther
              -o---o-
               |   |
              -o---o-
       current |  next
               @
              crawler
     */

    QBond& bond = getBond(0);
    SiteNum site = bond.getSiteNumber();
    Membrane& current = (Membrane&) ew[site];

    QBond& otherBond = current.getBond(Membrane.cOTHER);
    QBond& nextBond = current.getBond(Membrane.cNEXT);
    if (!otherBond.isAttached() || !nextBond.isAttached())
      return true;

    SiteNum otherSite = otherBond.getSiteNumber(site);
    SiteNum nextSite = nextBond.getSiteNumber(site);
    if (!ew.isAccessible(otherSite) || !ew.isAccessible(nextSite))
      return false;

    Membrane& other = (Membrane&) ew[otherSite];
    Membrane& next = (Membrane&) ew[nextSite];
    QBond& otherNextBond = other.getBond(Membrane.cNEXT);
    QBond& nextOtherBond = next.getBond(Membrane.cOTHER);
    if (!nextOtherBond.isAttached())
      return true;

    SiteNum nextOtherSite = nextOtherBond.getSiteNumber(nextSite);
    if (otherNextBond.isAttached() &&
        otherNextBond.getSiteNumber(otherSite) == nextOtherSite)
    {
      return true; // already attached correctly
    }
    if (!ew.isAccessible(nextOtherSite))
      return false;

    BS.Status status = bu.attachForce(otherSite, Membrane.cNEXT, nextOtherSite, Membrane.cPREV);
    return
      (status != BS.cINACCESSIBLE) &&
      (status != BS.cDISTANCE_EXCEEDS_MAX);
  }
}


quark Demo_MembraneCrawler : QStateT(3) + QBondableT(1) + QDiffusableT(100) {
  constant State cSTATE_ATTACH   = 0;
  constant State cSTATE_WORK     = 1;
  constant State cSTATE_ADVANCE  = 2;

  // return true when work is done to advance
  virtual Bool doWork();

  Void step() {
    if (isState(cSTATE_ATTACH)) {
      attach();
    } else if (isState(cSTATE_WORK)) {
      work();
    } else if (isState(cSTATE_ADVANCE)) {
      advance();
    }
  }

  Void attach() {
    AtomUtils au;
    BondStatus bs;
    BondUtils bu;
    EventWindow ew;

    QBond& bond = getBond(0);
    if (bond.isAttached())
      setState(cSTATE_WORK);

    // Find membrane to attach to
    Membrane membrane;
    WindowServices ws;
    ws.reset(1, bu.maxDist(membrane, (IBondable&) ew[0]));
    if (!ws.scan(au.getType(membrane)))
      return;
    SiteNum site = ws.getPick();

    if (bs.isOk(bu.attach(0, 0, site, 0)))
      setState(cSTATE_WORK);
  }

  Void work() {
    if (doWork())
      setState(cSTATE_ADVANCE);
  }

  Void advance() {
    BondStatus bs;
    BondUtils bu;

    // Move to "next" atom, try "other" it there's no next
    BS.Status status = bu.traverse(0, 0, Membrane.cNEXT);
    if (status == BS.cNO_NEXT)
      status = bu.traverse(0, 0, Membrane.cOTHER);

    if (bs.isOk(status))
      setState(cSTATE_WORK);
  }
}
