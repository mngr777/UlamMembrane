local typedef BondStatus BS;
local typedef EventWindow.SiteNum SiteNum;
local typedef EvalSearch ES;
local typedef PackageData PD;
local typedef STypeUtils STU;

/**
   \symbol DP
 */
element DemoParameters {
  /**
     Bootstrap automatically

     Attach TreeBuilder atom to the first item in input sequence.
   */
  parameter Bool pBOOTSTRAP = true;
}


/**
   \symbol De
 */
element Demo : QStateT(3) + QBondableT(2) + QMortal {
  constant State cSTATE_PLACE_MEMBRANE_BUILDER = 0;
  constant State cSTATE_BUILD_SEQUENCE         = 1;
  constant State cSTATE_ATTACH_FIRST           = 2;
  constant State cSTATE_COMPLETE               = 3;
  constant State cSTATE_ATTACH_TREE_BUILDER    = 4;

  Unsigned mCount = 0;

  @Override Void behave() {
    if (isState(cSTATE_PLACE_MEMBRANE_BUILDER)) {
      placeMembraneBuilder();
    } else if (isState(cSTATE_BUILD_SEQUENCE)) {
      buildSequence();
    } else if (isState(cSTATE_ATTACH_FIRST)) {
      attachFirst();
    } else if (isState(cSTATE_COMPLETE)) {
      complete();
    } else if (isState(cSTATE_ATTACH_TREE_BUILDER)) {
      attachTreeBuilder();
    } else if (isState(cSTATE_DONE)) {
      die();
    }
  }

  Void placeMembraneBuilder() {
    EventWindow ew;

    DemoInitialMembraneBuilder builder;
    ew[1] = builder;

    setState(cSTATE_BUILD_SEQUENCE);
  }

  Void buildSequence() {
    Demo_SequenceData data;

    SequenceBuilder builder;
    if (builder.buildNext(self, 0, data.getData(mCount), data.getAux(mCount)))
      mCount++;

    if (mCount == 2u && !getBond(1).isAttached()) {
      // Attach to first item, so we can close the ring later
      setState(cSTATE_ATTACH_FIRST);

    } else if (mCount >= data.cSIZE) {
      setState(cSTATE_COMPLETE);
    }
  }

  Void attachFirst() {
    BondStatus bs;
    BondUtils bu;
    EventWindow ew;

    QBond& bond = getBond(0);
    SiteNum secondSite = bond.getSiteNumber();
    Package& second = (Package&) ew[secondSite];

    QBond& prevBond = second.getBond(Package.cPREV);
    SiteNum firstSite = prevBond.getSiteNumber(secondSite);

    // Attach to bond 1
    if (bs.isOk(bu.attach(0, 1, firstSite, Package.cCOMMON)))
      setState(cSTATE_BUILD_SEQUENCE); // continue building sequence
  }

  Void complete() {
    BondStatus bs;
    BondUtils bu;

    SiteNum siteFirst = getBond(1).getSiteNumber();
    SiteNum siteLast = getBond(0).getSiteNumber();

    if (bs.isOk(bu.attach(siteFirst, Package.cPREV, siteLast, Package.cNEXT)))
      setState(cSTATE_ATTACH_TREE_BUILDER);
  }

  Void attachTreeBuilder() {
    DemoParameters params;
    if (!params.pBOOTSTRAP) {
      setState(cSTATE_DONE);
      return;
    }

    BondStatus bs;
    BondUtils bu;
    EventWindow ew;
    EventWindowMisc ewm;

    // Get first package
    QBond& firstBond = getBond(1);
    SiteNum firstSite = firstBond.getSiteNumber();
    Package& first = (Package&) ew[firstSite];

    // Place builder
    TreeBuilder builder;
    SiteNum site = ewm.findEmptySiteAround(first, 1u, bu.maxDist(builder, first));
    if (site == SiteNum.maxof)
      return;
    ew[site] = builder;

    // Attach to first package (replace ourselves)
    BS.Status status = bu.replace(firstSite, Package.cCOMMON, site, TreeBuilder.cSEQUENCE);
    if (!bs.isOk(status)) {
      Empty empty;
      ew[site] = empty;
      return;
    }
    setState(cSTATE_DONE);
  }
}


/**
   Basic crawler example:
   (with-input
     (if-attached
     +-(widh-dst           ;; Move to "next" if possible, otherwise try "other"
     |   Membrane.cNEXT,   ; TODO: shorten to (if-not (traverse-3) (traverse-2))
     |   (if-attached-next
     |     (traverse-3)
     |     (traverse-2)))
     +-(attach-to          ;; Find a membrane to attach to
         STU.cMEMBRANE)))

   # Bootstrap:
    1 (with-input
    2   (if-attached
    3   +-(with-reg1
    4   |   ES.cTAGGED | ES.cACTIVE
    5   |   (if-matches-flags
    6   |   +-(prog2
    7   |   |   (prog2
    8   |   |     (deactivate)
    9   |   |     (traverse-2))
   10   |   |   (with-output
   11   |   |     (if
   12   |   |       (with-reg1
   13   |   |         STU.cTREE_BUILDER
   14   |   |         (with-dst
   15   |   |           TreeBuilder.cSEQUENCE
   16   |   |           (build)))
   17   |   |       (with-dst-1
   18   |   |         (with-reg1
   19   |   |           Package.cCOMMON
   20   |   |           (move-to-other-next)))))
   21   |   +-(traverse-2)))
   22   +-(attach-to-flags
   23       STU.cPACKAGE
   24       ES.cNO_EXEC)))

   # Build second membrane layer atoms:
    1 (with-input
    2  (if-attached
    3  +-(with-dst-2                    ; "other" membrane bond
    4  |   (if-attached-next
    5  |   +-(with-dst-3                ;; Move to "next" if attached, otherwise try "other"
    6  |   |   (if-attached-next
    7  |   |     (traverse-3)           ; move to "next" membrane atom
    8  |   |     (traverse-2)))         ; move to "other" membrane atom
    9  |   +-(with-output               ;; Attach new membrane atom to "other" bond
   10  |       (with-dst-2              ; Membrane.cOTHER = 2
   11  |         (if
   12  |           (with-reg1
   13  |             STU.cMEMBRANE      ; membrane stype
   14  |             (build))           ; build attached to Exec by "other" bond
   15  |           (move-to-other))))   ; attach to input membrane's "other" bond
   16  +-(attach-to                     ;; Find a membrane to attach to
   17      STU.cMEMBRANE)))

   # Repair the membrane:
   1. Next layer atoms are there,        2. Atoms of both layers are attached,
      but not attached to each other:       but one layer has extra atoms in between
                                            because of growth:
   "other" layer:  -o   o       -o---o       -o-------o-      -o-------o-
                    |   |        |   |        |       |        |       |
   current layer:  -o---o-  ->  -o---o-      -o---o---o-  ->  -o---o---o
                    |            |            |                    |
                    @            @            @                    @

      Connect the atoms in "other" layer.   Move to next atom, handle it later as case 3.

    3. Atoms in "other" layer attached
       incorrectly after atom was inserted
       because of growth and "other"
       layer atom was attached to it:

   "other" layer:  -o-------o-      -o---o   o
                    |   o   |        |   |   |
                    |   |   |        |   |   |
   current layer:  -o---o---o-  ->  -o---o---o
                    |                    |
                    @                    o

    1 (with-input
    2   (if-attached
    3   +-(prog2
    4   |   (with-dst-2
    5   |     (if-attached-next                                  ;; Does current membrane atom have "other"?
    6   |     +-(if
    7   |     | +-(attach-other-to-next)                         ; * attach output bond to "other" membrane
    8   |     | +-(with-dst-3
    9   |     |     (if-attached-next                            ;   Is there next membrane atom?
   10   |     |     +-(prog2
   11   |     |     |   (traverse)                               ;   - move to next
   12   |     |     |   (with-dst-2
   13   |     |     |     (if-attached-next                      ;     does next atom have "other" attached?
   14   |     |     |     +-(prog2
   15   |     |     |     |   (traverse)                         ;     1. move to it
   16   |     |     |     |   (with-dst-1
   17   |     |     |     |     (if-other-matches-next           ;     2. is it "next" for output?
   18   |     |     |     |       (noop)                         ;        nothing to do then
   19   |     |     |     |       (with-reg1
   20   |     |     |     |         Membrane.cNEXT
   21   |     |     |     |         (if-other-next-matches-next        TODO: fix comments
   22   |     |     |     |           (swap-input-output)
   23   |     |     |     |           (prog2                     ;     3. connect membrane prev/next atoms,
   24   |     |     |     |             (connect-other-force)    ;        break bonds if already bonded [cases 1, 3]
   25   |     |     |     |             (with-dst-2              ;     move to other
   26   |     |     |     |               (traverse))))))))
   27   |     |     |     +-(noop))))
   28   |     |     +-(swap-input-output))))                     ;   - no next atom, move to "other"
   29   |     +-(traverse-3)))                                    ; * move to next
   30   |   (detach-other))                                      ; detach output bond
   31   +-(attach-to                                             ;; Find a membrane to attach to
   32       STU.cMEMBRANE)))

   # Growth
    1 (with-input
    2   (if-attached
    3   +-(with-dst-3
    4   |   (if-attached-next    ;; Does current membrane atom have "next"?
    5   |   +-(with-reg1         ;  * insert a new membrane atom in 1/10000 of cases
    6   |   |   100
    7   |   |   (if-one-in
    8   |   |     (insert-seq)
    9   |   |     (traverse)))
   10   |   +-(traverse-2)))     ;  * no "next" atom move to "other"
   11   +-(attach-to
   12       STU.cMEMBRANE)))

 */
transient Demo_SequenceData {
  typedef DataUtils.Datum Datum;
  typedef DataUtils.Byte Byte;
  typedef ITaggable.Tag Tag;
  typedef PackageData.Arity Arity;
  typedef PackageData.Type Type;
  typedef PackageData.Symbol Symbol;

  typedef EvalBlock EB;
  typedef EvalConditional EC;
  typedef EvalFunction EF;

  typedef Bits(Type.sizeof + Byte.sizeof) Item ;

  constant Item cBLCK = (Item) PD.cTYPE_BLOCK << Byte.sizeof;
  constant Item cFUNC = (Item) PD.cTYPE_FUNCTION << Byte.sizeof;
  constant Item cCOND = (Item) PD.cTYPE_CONDITIONAL << Byte.sizeof;
  constant Item cCNST = (Item) PD.cTYPE_CONSTANT << Byte.sizeof;

  constant Item cACTIVE = (Item) 1 << Byte.sizeof;

  constant Unsigned cSIZE = 85;

  PackageData pd;

  EvalBlock eb;
  EvalConditional ec;
  EvalFunction ef;

  Item items[cSIZE * 2] = {
    /* # Bootstrap */
    /*  1 */ cBLCK | EB.cWITH_INPUT, (Tag) 0x1,
    /*  2   */ cCOND | EC.cIF_ATTACHED, 0,
    /*  3     */ cBLCK | EB.cWITH_REG1, 0,
    /*  4       */ cCNST | (Byte) (ES.cTAGGED | ES.cACTIVE), 0,
    /*  5       */ cCOND | EC.cIF_MATCHES_FLAGS, 0,
    /*  6         */ cFUNC | EF.cPROG2, 0,
    /*  7           */ cFUNC | EF.cPROG2, 0,
    /*  8             */ cFUNC | EF.cDEACTIVATE, 0,
    /*  9             */ cFUNC | EF.cTRAVERSE_2, 0,
    /* 10           */ cBLCK | EB.cWITH_OUTPUT, 0,
    /* 11             */ cCOND | EC.cIF, 0,
    /* 12               */ cBLCK | EB.cWITH_REG1, 0,
    /* 13                 */ cCNST | (Byte) STU.cTREE_BUILDER, 0,
    /* 14                 */ cBLCK | EB.cWITH_DST, 0,
    /* 15                   */ cCNST | (Byte) TreeBuilder.cSEQUENCE, 0,
    /* 16                   */ cFUNC | EF.cBUILD, 0,
    /* 17               */ cBLCK | EB.cWITH_DST_1, 0,
    /* 18                 */ cBLCK | EB.cWITH_REG1, 0,
    /* 19                   */ cCNST | (Byte) Package.cCOMMON, 0,
    /* 20                   */ cFUNC | EF.cMOVE_TO_OTHER_NEXT, 0,
    /* 21         */ cFUNC | EF.cTRAVERSE_2, 0,
    /* 22     */ cFUNC | EF.cATTACH_TO_FLAGS, 0,
    /* 23       */ cCNST | (Byte) STU.cPACKAGE, 0,
    /* 24       */ cCNST | (Byte) ES.cNO_EXEC, 0,

    /* # Build second membrane layer atoms */
    /*  1 */ cBLCK | EB.cWITH_INPUT, cACTIVE | (Tag) 0x2,
    /*  2   */ cCOND | EC.cIF_ATTACHED, 0,
    /*  3     */ cBLCK | EB.cWITH_DST_2, 0,
    /*  4       */ cCOND | EC.cIF_ATTACHED_NEXT, 0,
    /*  5         */ cBLCK | EB.cWITH_DST_3, 0,
    /*  6           */ cCOND | EC.cIF_ATTACHED_NEXT, 0,
    /*  7             */ cFUNC | EF.cTRAVERSE_3, 0,
    /*  8             */ cFUNC | EF.cTRAVERSE_2, 0,
    /*  9         */ cBLCK | EB.cWITH_OUTPUT, 0,
    /* 10           */ cBLCK | EB.cWITH_DST_2, 0,
    /* 11             */ cCOND | EC.cIF, 0,
    /* 12               */ cBLCK | EB.cWITH_REG1, 0,
    /* 13                   */ cCNST | (Byte) STU.cMEMBRANE, 0,
    /* 14                   */ cFUNC | EF.cBUILD, 0,
    /* 15                 */ cFUNC | EF.cMOVE_TO_OTHER, 0,
    /* 16     */ cFUNC | EF.cATTACH_TO, 0,
    /* 17       */ cCNST | STU.cMEMBRANE, 0,

    /* # Repair the membrane */
    /*  1 */ cBLCK | EB.cWITH_INPUT, cACTIVE | (Tag) 0x2,
    /*  2   */ cCOND | EC.cIF_ATTACHED, 0,
    /*  3     */ cFUNC | EF.cPROG2, 0,
    /*  4       */ cBLCK | EB.cWITH_DST_2, 0,
    /*  5         */ cCOND | EC.cIF_ATTACHED_NEXT, 0,
    /*  6           */ cCOND | EC.cIF, 0,
    /*  7             */ cFUNC | EF.cATTACH_OTHER_TO_NEXT, 0,
    /*  8             */ cBLCK | EB.cWITH_DST_3, 0,
    /*  9               */ cCOND | EC.cIF_ATTACHED_NEXT, 0,
    /* 10                 */ cFUNC | EF.cPROG2, 0,
    /* 11                   */ cFUNC | EF.cTRAVERSE, 0,
    /* 12                   */ cBLCK | EB.cWITH_DST_2, 0,
    /* 13                     */ cCOND | EC.cIF_ATTACHED_NEXT, 0,
    /* 14                       */ cFUNC | EF.cPROG2, 0,
    /* 15                         */ cFUNC | EF.cTRAVERSE, 0,
    /* 16                         */ cBLCK | EB.cWITH_DST_1, 0,
    /* 17                           */ cCOND | EC.cIF_OTHER_MATCHES_NEXT, 0,
    /* 18                             */ cFUNC | EF.cNOOP, 0,
    /* 19                             */ cBLCK | EB.cWITH_REG1, 0,
    /* 20                               */ cCNST | (Byte) Membrane.cNEXT, 0,
    /* 21                               */ cCOND | EC.cIF_OTHER_NEXT_MATCHES_NEXT, 0,
    /* 22                                 */ cFUNC | EF.cSWAP_INPUT_OUTPUT, 0,
    /* 23                                 */ cFUNC | EF.cPROG2, 0,
    /* 24                                   */ cFUNC | EF.cCONNECT_OTHER_FORCE, 0,
    /* 25                                   */ cBLCK | EB.cWITH_DST_2, 0,
    /* 26                                     */ cFUNC | EF.cTRAVERSE, 0,
    /* 27                       */ cFUNC | EF.cNOOP, 0,
    /* 28                 */ cFUNC | EF.cSWAP_INPUT_OUTPUT, 0,
    /* 29           */ cFUNC | EF.cTRAVERSE_3, 0,
    /* 30       */ cFUNC | EF.cDETACH_OTHER, 0,
    /* 31   */ cFUNC | EF.cATTACH_TO, 0,
    /* 32     */ cCNST | (Byte) STU.cMEMBRANE, 0,

    /* # Grow the membrane */
    /*  1 */ cBLCK | EB.cWITH_INPUT, cACTIVE | (Tag) 0x3,
    /*  2   */ cCOND | EC.cIF_ATTACHED, 0,
    /*  3     */ cBLCK | EB.cWITH_DST_3, 0,
    /*  4       */ cCOND | EC.cIF_ATTACHED_NEXT, 0,
    /*  5         */ cBLCK | EB.cWITH_REG1, 0,
    /*  6           */ cCNST | (Byte) 100, 0,
    /*  7           */ cCOND | EC.cIF_ONE_IN, 0,
    /*  8             */ cFUNC | EF.cINSERT_SEQ, 0,
    /*  9             */ cFUNC | EF.cTRAVERSE, 0,
    /* 10           */ cFUNC | EF.cTRAVERSE_2, 0,
    /* 11     */ cFUNC | EF.cATTACH_TO, 0,
    /* 12       */ cCNST | (Byte) STU.cMEMBRANE, 0
  };

  Datum getData(Unsigned i) {
    Item item = items[i * 2u];

    Type type = (Type) (item >> Byte.sizeof);
    Byte value = (Byte) item;
    Arity arity = getArity(type, (Symbol) value);

    // DebugUtils dbg;
    // dbg.print("sequence item (num/arity):");
    // dbg.print(i + 1u);
    // dbg.print(arity);

    Datum data = PD.cNO_DATA;
    data = pd.setArity(data, arity);
    data = pd.setType(data, type);
    data = pd.setValue(data, value);
    return data;
  }

  Datum getAux(Unsigned i) {
    Item item = items[i * 2u + 1u];

    Tag tag = (Tag) item;
    Bool isActive = (item & cACTIVE) != 0x0;

    Datum data = PD.cNO_DATA;
    if (tag != 0x0) {
      data = pd.setTag(data, tag);
      data = pd.setIsActive(data, isActive);
      data = pd.setIsActiveDefault(data, isActive);
    }
    return data;
  }

  Arity getArity(Type type, Symbol symbol) {
    Arity arity = 0;
    if (type == PD.cTYPE_BLOCK) {
      arity = eb.getArity(symbol);
    } else if (type == PD.cTYPE_CONDITIONAL) {
      arity = ec.getArity(symbol);
    } else if (type == PD.cTYPE_FUNCTION) {
      arity = ef.getArity(symbol);
    }
    return arity;
  }
}


/**
   \symbol MS
 */
element DemoMoverSouth : DemoQMoverT(0) {}

/**
   \symbol ME
 */
element DemoMoverEast : DemoQMoverT(2) {}

/**
   \symbol MN
 */
element DemoMoverNorth : DemoQMoverT(4) {}

/**
   \symbol MW
 */
element DemoMoverWest : DemoQMoverT(6) {}
