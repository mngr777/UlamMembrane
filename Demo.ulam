local typedef BondStatus BS;
local typedef EventWindow.SiteNum SiteNum;
local typedef PackageData PD;

element Demo : QStateT(3) + QBondableT(1) + QMortal {
  constant State cPLACE_MEMBRANE_BUILDER = 0;
  constant State cBUILD_SEQUENCE         = 1;

  Unsigned mCount = 0;

  @Override Void behave() {
    if (isState(cPLACE_MEMBRANE_BUILDER)) {
      placeMembraneBuilder();
    } else if (isState(cBUILD_SEQUENCE)) {
      buildSequence();
    } else if (isState(cSTATE_DONE)) {
      die();
    }
  }

  Void placeMembraneBuilder() {
    EventWindow ew;

    Demo_MembraneBuilder builder;
    ew[1] = builder;

    setState(cBUILD_SEQUENCE);
  }

  Void buildSequence() {
    Demo_SequenceData data;

    SequenceBuilder builder;
    if (builder.buildNext(self, 0, data.getData(mCount), data.getAux(mCount)))
      mCount++;

    if (mCount >= data.cSIZE)
      setState(cSTATE_DONE);
  }
}


/**
   \symbol DT
 */
element Demo_TreeBuilder : QTreeBuilder + QBondableT(2) + QDiffusableT(100) + QMortal {
  constant State cSTATE_DETACH_SEQUENCE = cSTATE_BUILD_DONE;
  constant State cSTATE_ATTACH_EXEC     = cSTATE_BUILD_DONE + 1;

  virtual IBondable& getBondable() {
    return self;
  }

  @Override Void behave() {
    step();

    if (isState(cSTATE_DONE)) {
      die();
    } else {
      diffuse();
    }
  }

  Void step() {
    if (isState(cSTATE_DETACH_SEQUENCE)) {
      detachSequence();

    } else if (isState(cSTATE_ATTACH_EXEC)) {
      attachExec();

    } else {
      self.QTreeBuilder.step();
    }
  }

  Void detachSequence() {
    getBond(cSEQUENCE).detach();
    setState(cSTATE_ATTACH_EXEC);
  }

  Void attachExec() {
    BondStatus bs;
    BondUtils bu;
    EventWindow ew;
    EventWindowMisc ewm;

    QBond& bond = getBond(cTREE);
    SiteNum treeSite = bond.getSiteNumber();
    Package& tree = (Package&) ew[treeSite];

    // Build exec
    Exec exec;
    SiteNum site = ewm.findEmptySiteAround(treeSite, 1u, bu.maxDist(exec, tree));
    if (site == SiteNum.maxof)
      return;
    ew[site] = exec;

    // Replace ourselves with exec
    BS.Status status = bu.replace(treeSite, Package.cCOMMON, site, Exec.cPROGRAM);
    if (!bs.isOk(status)) {
      Empty empty;
      ew[site] = empty;
      return;
    }

    setState(cSTATE_DONE);
  }
}


local typedef QBondableT(1) QBondable1;

/**
   \symbol DM
 */
element Demo_MembraneBuilder : QStateT(3) + QBondableT(1) + QMortal {
  typedef C2D.Dir Dir;

  constant Unsigned(5) cSIDE_LENGTH = 16;
  constant Unsigned(2) cSTEP_LENGTH = 2;

  constant State cSTATE_MOVE_OUT = 0;
  constant State cSTATE_BUILD    = 1;
  constant State cSTATE_ANCHOR   = 2;
  constant State cSTATE_TRAVERSE = 3;
  constant State cSTATE_FORWARD  = 4;
  constant State cSTATE_CLOSE    = 5;

  Dir mDir = 0; // South
  Unsigned(5) mCount = 0;
  Unsigned(2) mMoveCount = 0;

  @Override Void behave() {
    if (isState(cSTATE_MOVE_OUT)) {
      moveOut();
    } else if (isState(cSTATE_BUILD)) {
      build();
    } else if (isState(cSTATE_ANCHOR)) {
      anchor();
    } else if (isState(cSTATE_TRAVERSE)) {
      traverse();
    } else if (isState(cSTATE_FORWARD)) {
      forward();
    } else if (isState(cSTATE_CLOSE)) {
      close();
    } else if (isState(cSTATE_DONE)) {
      die();
    }
  }

  Void moveOut() {
    // NOTE: cannot do checks after swapping
    if (mCount >= cSIDE_LENGTH * cSTEP_LENGTH / 2) {
      mCount = 0;
      setState(cSTATE_BUILD);
      return;
    }

    EventWindow ew;
    SwapHelper sh;
    C2D origin;
    C2D coord = origin.neighbor(5); // North-West
    if (ew.isEmpty(coord)) {
      mCount++; // increment _before_ swapping
      if (!sh.swap(origin, coord))
        mCount--;
    }
  }

  Void build() {
    BondStatus bs;
    BondUtils bu;
    EventWindow ew;
    EventWindowMisc ewm;

    // Build
    SiteNum site = ewm.findEmptySite(1, 2);
    if (site == SiteNum.maxof)
      return;
    Membrane membrane;
    ew[site] = membrane;

    BS.Status status = BS.cOK;
    QBond& bond = getBond(0);
    if (!bond.isAttached()) {
      // First membrane atom, attach to self
      status = bu.attach(0, 0, site, Membrane.cCOMMON);
    } else {
      // Attach to previous membrane atom
      status = bu.attach(bond.getSiteNumber(), Membrane.cNEXT, site, Membrane.cPREV);
    }

    if (bs.isOk(status)) {
      setState(cSTATE_ANCHOR);

    } else {
      Empty empty;
      ew[site] = empty;
      return;
    }
  }

  Void anchor() {
    BondStatus bs;
    BondUtils bu;
    CoordUtils cu;
    EventWindow ew;
    EventWindowMisc ewm;

    QBond& bond = getBond(0);
    SiteNum membraneSite = bond.getSiteNumber();
    Membrane& membrane = (Membrane&) ew[membraneSite];
    QBond& otherBond = membrane.getBond(Membrane.cOTHER);

    if (mCount > 0 || otherBond.isAttached()) {
      setState(cSTATE_TRAVERSE);
      return;
    }

    // Build anchor
    // TODO: find a way to place anchors that mostly works
    C2D coord = ew.getCoordRaw(getForwardSite());
    coord = cu.rotateLeft(coord);
    SiteNum site = ew.getSiteNumberRaw(-coord);
    if (!ew.isEmpty(site))
      return;
    Anchor anchor;
    ew[site] = anchor;

    // Attach to membrane
    BS.Status status = bu.attach(site, 0, membraneSite, Membrane.cOTHER);
    if (!bs.isOk(status)) {
      Empty empty;
      ew[site] = empty;
      return;
    }
  }

  Void traverse() {
    BondStatus bs;
    BondUtils bu;
    EventWindow ew;

    BS.Status status = bu.traverse(0, 0, Membrane.cNEXT);
    if (bs.isOk(status) || status == BS.cNO_NEXT)
      setState(cSTATE_FORWARD);
  }

  Void forward() {
    // NOTE: cannot do checks after swapping
    if (mMoveCount >= cSTEP_LENGTH) {
      mMoveCount = 0;
      mCount++;
      if (mCount >= cSIDE_LENGTH) {
        // Side finished, move to next side
        mCount = 0;
        mDir = getNextDir();
        if (mDir == 0) {
          // Last side finished, close the membrane
          setState(cSTATE_CLOSE);
          return;
        }
      }
      setState(cSTATE_BUILD);
      return;
    }

    EventWindow ew;
    SwapHelper sh;

    SiteNum forwardSite = getForwardSite();
    if (ew.isEmpty(forwardSite)) {
      mMoveCount++; // increment _before_ swapping
      if (!sh.swap(0, forwardSite))
        mMoveCount--;
    }
  }

  Void close() {
    BondStatus bs;
    BondUtils bu;
    EventWindow ew;

    QBond& bond = getBond(0);
    SiteNum prevSite = bond.getSiteNumber();
    SiteNum nextSite = getFirstSite();
    if (nextSite == SiteNum.maxof)
      return;

    BS.Status status = bu.attach(prevSite, Membrane.cNEXT, nextSite, Membrane.cPREV);
    if (bs.isOk(status))
      setState(cSTATE_DONE);
  }

  SiteNum getFirstSite() {
    EventWindow ew;
    MDist mdist;

    for (Int s = 1; s <= mdist.getLastIndex(4); s++) {
      SiteNum site = (SiteNum) s;
      Atom& atom = ew[site];
      if (atom as Membrane)
        if (!atom.getBond(Membrane.cPREV).isAttached())
          return site;
    }
    return SiteNum.maxof;
  }

  Dir getNextDir() {
    return (Dir) (((Int) mDir + 2) % 8);
  }

  SiteNum getForwardSite() {
    EventWindow ew;
    C2D origin;
    return ew.getSiteNumber(origin.neighbor(mDir));
  }

  @Override Void renderGraphics() {
    self.QBondable1.renderGraphics();

    Drawable drawable;
    if (!drawable.canDraw())
      return;

    ColorUtils cu;
    C2D start;
    C2D end = start.neighbor(mDir) * (Drawable.cUNITS_PER_SITE * 3 / 4);
    ARGB oncol = cu.color(0x00ffffff);
    ARGB offcol = oncol;
    drawable.drawMaskedLine(start, end, oncol, offcol, 0xffffffff);
  }
}


/**
   (with-input
     (if-attached
       (traverse-3) ; next membrane
       (attach-to
         3) ; membrane stype
 */
transient Demo_SequenceData {
  typedef DataUtils.Datum Datum;
  typedef DataUtils.Byte Byte;
  typedef ITaggable.Tag Tag;
  typedef PackageData.Arity Arity;
  typedef PackageData.Type Type;
  typedef PackageData.Symbol Symbol;

  typedef EvalBlock EB;
  typedef EvalConditional EC;
  typedef EvalFunction EF;

  typedef Bits(Type.sizeof + Byte.sizeof) Item ;

  constant Item cBLCK = (Item) PD.cTYPE_BLOCK << Byte.sizeof;
  constant Item cFUNC = (Item) PD.cTYPE_FUNCTION << Byte.sizeof;
  constant Item cCOND = (Item) PD.cTYPE_CONDITIONAL << Byte.sizeof;
  constant Item cCNST = (Item) PD.cTYPE_CONSTANT << Byte.sizeof;

  constant Item cACTIVE = (Item) 1 << Byte.sizeof;

  constant Unsigned cSIZE = 6;

  PackageData pd;

  EvalBlock eb;
  EvalConditional ec;
  EvalFunction ef;

  Item items[cSIZE * 2] = {
    /*  */ cBLCK | EB.cWITH_INPUT, cACTIVE | (Tag) 0x1,
    /*    */ cCOND | EC.cIF_ATTACHED, 0x0,
    /*      */ cFUNC | EF.cTRAVERSE_3, 0x0,
    /*      */ cFUNC | EF.cATTACH_TO, 0x0,
    /*        */ cCNST | (Byte) 3, 0x0
  };

  Datum getData(Unsigned i) {
    Item item = items[i * 2u];

    Type type = (Type) (item >> Byte.sizeof);
    Byte value = (Byte) item;
    Arity arity = getArity(type, (Symbol) value);

    Datum data = PD.cNO_DATA;
    data = pd.setArity(data, arity);
    data = pd.setType(data, type);
    data = pd.setValue(data, value);
    return data;
  }

  Datum getAux(Unsigned i) {
    Item item = items[i * 2u + 1u];

    Tag tag = (Tag) item;
    Bool isActive = (item & cACTIVE) != 0x0;

    Datum data = PD.cNO_DATA;
    if (tag != 0x0) {
      data = pd.setTag(data, tag);
      data = pd.setIsActive(data, isActive);
    }
    return data;
  }

  Arity getArity(Type type, Symbol symbol) {
    Arity arity = 0;
    if (type == PD.cTYPE_BLOCK) {
      arity = eb.getArity(symbol);
    } else if (type == PD.cTYPE_CONDITIONAL) {
      arity = ec.getArity(symbol);
    } else if (type == PD.cTYPE_FUNCTION) {
      arity = ef.getArity(symbol);
    }
    return arity;
  }
}

